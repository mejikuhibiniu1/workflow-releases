name: Scrape Online-Fix Games

on:
  schedule:
    - cron: '0 0 * * *' # every day at 00:00 UTC
  workflow_dispatch: # Allow manual trigger
    inputs:
      pages:
        description: 'Number of pages to scrape'
        required: false
        default: '2'
      fetch_appids:
        description: 'Fetch Steam AppIDs (slower)'
        required: false
        type: boolean
        default: true

jobs:
  scrape-online-fix:
    runs-on: ubuntu-latest
    permissions:
      contents: write

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4

      - name: Setup Node.js
        uses: actions/setup-node@v4
        with:
          node-version: '22'

      - name: Install dependencies
        run: |
          npm install axios cheerio @prisma/client prisma algoliasearch

      - name: Generate Prisma Client
        run: npx prisma generate
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Scrape Online-Fix Games
        id: scrape
        run: |
          # Create scraper script
          cat > scrape-workflow.js << 'EOF'
          const axios = require('axios');
          const cheerio = require('cheerio');
          const fs = require('fs');
          const { algoliasearch } = require('algoliasearch');

          // Cookies from environment
          const COOKIES = {
            online_fix_auth: process.env.ONLINE_FIX_AUTH || '',
            dle_user_id: process.env.ONLINE_FIX_DLE_USER_ID || '',
            dle_password: process.env.ONLINE_FIX_DLE_PASSWORD || '',
            PHPSESSID: process.env.ONLINE_FIX_PHPSESSID || '',
            cf_clearance: process.env.ONLINE_FIX_CF_CLEARANCE || '',
          };

          const cookieString = `online_fix_auth=${COOKIES.online_fix_auth}; dle_user_id=${COOKIES.dle_user_id}; dle_password=${COOKIES.dle_password}; PHPSESSID=${COOKIES.PHPSESSID}; cf_clearance=${COOKIES.cf_clearance}`;

          const headers = {
            Accept: 'text/html,application/xhtml+xml,application/xml;q=0.9,image/avif,image/webp,image/apng,*/*;q=0.8',
            'Accept-Encoding': 'gzip, deflate, br, zstd',
            'Accept-Language': 'en-US,en;q=0.9',
            'Cache-Control': 'max-age=0',
            Cookie: cookieString,
            'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/140.0.0.0 Safari/537.36',
          };

          // Initialize Algolia client
          let algoliaClient = null;
          let algoliaIndexName = process.env.NEXT_PUBLIC_ALGOLIA_INDEX_NAME || 'games';

          function getAlgoliaClient() {
            if (!algoliaClient) {
              const appId = process.env.NEXT_PUBLIC_ALGOLIA_APP_ID;
              const apiKey = process.env.NEXT_PUBLIC_ALGOLIA_SEARCH_API_KEY;

              if (!appId || !apiKey) {
                console.log('⚠️  Algolia credentials not found, database search will be disabled');
                return null;
              }

              algoliaClient = algoliasearch(appId, apiKey);
              console.log('✅ Algolia client initialized');
            }
            return algoliaClient;
          }

          function cleanText(text) {
            if (!text) return '';
            return text
              .replace(/[\u{1F300}-\u{1F9FF}]/gu, '')
              .replace(/[\u{2600}-\u{26FF}]/gu, '')
              .replace(/[\u{2700}-\u{27BF}]/gu, '')
              .replace(/�/g, '')
              .replace(/\s+/g, ' ')
              .trim();
          }

          function normalizeGameName(name) {
            return name
              .toLowerCase()
              .replace(/\s*-?\s*online[-\s]?fix/gi, '')
              .replace(/\s*online\s*/gi, ' ')
              .replace(/\([^)]*\)/g, '')
              .replace(/[^a-z0-9]/g, '')
              .trim();
          }

          async function searchGameInDatabase(gameName) {
            try {
              const client = getAlgoliaClient();
              if (!client) {
                console.log('  ⚠️  Algolia not available, skipping database search');
                return null;
              }

              // Clean the game name (remove online-fix, parentheses)
              const cleanName = gameName
                .replace(/\s*-?\s*online[-\s]?fix/gi, '')
                .replace(/\s*online\s*/gi, ' ')
                .replace(/\([^)]*\)/g, '')
                .trim();

              console.log(`  🔍 Searching Algolia for: "${cleanName}"`);

              // Search using Algolia - it handles fuzzy matching automatically
              const searchResult = await client.searchSingleIndex({
                indexName: algoliaIndexName,
                searchParams: {
                  query: cleanName,
                  hitsPerPage: 5,
                  // Enable typo tolerance for better fuzzy matching
                  typoTolerance: true,
                },
              });

              if (searchResult.hits && searchResult.hits.length > 0) {
                const topHit = searchResult.hits[0];
                console.log(`  ✅ Found via Algolia: "${topHit.name}" (AppID: ${topHit.appid})`);
                return topHit.appid;
              }

              console.log(`  ⚠️  No match found in Algolia for "${cleanName}"`);
              return null;
            } catch (error) {
              console.log(`  ❌ Algolia search error: ${error.message}`);
              return null;
            }
          }

          async function extractAppId(gameUrl, gameTitle) {
            try {
              const response = await axios.get(gameUrl, {
                headers,
                maxRedirects: 5,
                validateStatus: (status) => status < 600,
                timeout: 15000,
                responseType: 'arraybuffer',
              });

              if (response.status !== 200) return null;

              const decoder = new TextDecoder('utf-8');
              const html = decoder.decode(response.data);
              const $ = cheerio.load(html);

              let appid = null;

              $('a[href*="store.steampowered.com/app/"]').each((i, elem) => {
                const href = $(elem).attr('href');
                const match = href?.match(/\/app\/(\d+)/);
                if (match) {
                  appid = match[1];
                  return false;
                }
              });

              if (!appid) {
                $('a[href*="steamdb.info/app/"]').each((i, elem) => {
                  const href = $(elem).attr('href');
                  const match = href?.match(/\/app\/(\d+)/);
                  if (match) {
                    appid = match[1];
                    return false;
                  }
                });
              }

              if (!appid) {
                const bodyText = $('body').text();
                const match = bodyText.match(/(?:AppID|App ID|Steam ID)[\s:]+(\d{4,7})/i);
                if (match) appid = match[1];
              }

              if (!appid && gameTitle) {
                console.log(`  Searching database for: ${gameTitle}`);
                appid = await searchGameInDatabase(gameTitle);
                if (appid) console.log(`  Found in DB: ${appid}`);
              }

              return appid;
            } catch (error) {
              return null;
            }
          }

          async function fetchDownloadUrls(gameTitle) {
            try {
              const cleanGameName = gameTitle
                .replace(/\s*-?\s*online[-\s]?fix/gi, '')
                .replace(/\s*online\s*/gi, ' ')
                .replace(/\([^)]*\)/g, '')
                .replace(/:/g, '')
                .trim();

              const encodedGameName = encodeURIComponent(cleanGameName);
              const url = `https://uploads.online-fix.me:2053/uploads/${encodedGameName}/Fix%20Repair/`;

              const response = await axios.get(url, {
                headers: {
                  'Cookie': cookieString,
                  'User-Agent': 'Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36',
                },
                maxRedirects: 5,
                validateStatus: (status) => status < 600,
                timeout: 15000,
              });

              if (response.status !== 200) return [];

              const $ = cheerio.load(response.data);
              const downloadUrls = [];

              $('a[href]').each((i, elem) => {
                const href = $(elem).attr('href');
                if (href && !href.includes('..') && !href.endsWith('/')) {
                  const fullUrl = href.startsWith('http') ? href : `${url}${href}`;
                  downloadUrls.push(fullUrl);
                }
              });

              return downloadUrls;
            } catch (error) {
              return [];
            }
          }

          async function scrapePage(pageNumber, fetchAppIds) {
            try {
              const url = pageNumber === 1 ? 'https://online-fix.me/' : `https://online-fix.me/page/${pageNumber}/`;
              console.log(`Scraping page ${pageNumber}: ${url}`);

              const response = await axios.get(url, {
                headers,
                maxRedirects: 5,
                validateStatus: (status) => status < 600,
                timeout: 30000,
                responseType: 'arraybuffer',
              });

              if (response.status !== 200) {
                console.log(`Failed to fetch page ${pageNumber}`);
                return null;
              }

              const decoder = new TextDecoder('utf-8');
              const html = decoder.decode(response.data);
              const $ = cheerio.load(html);
              const games = [];

              $('article').each((i, elem) => {
                const $elem = $(elem);
                const rawTitle = $elem.find('h2, h3, .title, .post-title').first().text().trim();
                const title = cleanText(rawTitle);
                const link = $elem.find('a').first().attr('href');
                if (title && link) games.push({ title, link, appid: null });
              });

              if (games.length === 0) {
                $('.post, .game-post, .entry').each((i, elem) => {
                  const $elem = $(elem);
                  const rawTitle = $elem.find('h2, h3, .title, .post-title').first().text().trim();
                  const title = cleanText(rawTitle);
                  const link = $elem.find('a').first().attr('href');
                  if (title && link) games.push({ title, link, appid: null });
                });
              }

              console.log(`Found ${games.length} games on page ${pageNumber}`);

              if (fetchAppIds && games.length > 0) {
                console.log('Extracting Steam AppIDs...');
                for (let i = 0; i < games.length; i++) {
                  const game = games[i];
                  console.log(`[${i + 1}/${games.length}] ${game.title}`);
                  const appid = await extractAppId(game.link, game.title);
                  game.appid = appid;
                  if (appid) console.log(`  AppID: ${appid}`);
                  if (i < games.length - 1) await new Promise(r => setTimeout(r, 1000));
                }
              }

              return { pageNumber, games, hasGames: games.length > 0 };
            } catch (error) {
              console.log(`Error scraping page ${pageNumber}: ${error.message}`);
              return null;
            }
          }

          async function loadExistingGames() {
            try {
              const { PrismaClient } = require('@prisma/client');
              const prisma = new PrismaClient();

              console.log('Loading existing games from onlineFixes table...');

              const existingGames = await prisma.onlineFixes.findMany({
                select: {
                  appid: true,
                  games: {
                    select: {
                      name: true,
                    },
                  },
                },
              });

              await prisma.$disconnect();

              const existingAppIds = new Set(existingGames.map(g => g.appid));
              const existingGameNames = new Set(
                existingGames
                  .filter(g => g.games?.name)
                  .map(g => normalizeGameName(g.games.name))
              );

              console.log(`Loaded ${existingAppIds.size} existing AppIDs and ${existingGameNames.size} game names`);

              return { existingAppIds, existingGameNames };
            } catch (error) {
              console.log(`Error loading existing games: ${error.message}`);
              return { existingAppIds: new Set(), existingGameNames: new Set() };
            }
          }

          async function insertGamesToDatabase(games) {
            try {
              const { PrismaClient } = require('@prisma/client');
              const prisma = new PrismaClient();

              console.log(`\n📝 Inserting ${games.length} games into onlineFixes table...`);

              let inserted = 0;
              let skipped = 0;
              let errors = 0;

              for (const game of games) {
                if (!game.appid) {
                  console.log(`  ⏭️  Skipping ${game.title} (no AppID)`);
                  skipped++;
                  continue;
                }

                try {
                  const gameExists = await prisma.game.findUnique({
                    where: { appid: game.appid },
                    select: { appid: true },
                  });

                  if (!gameExists) {
                    console.log(`  ⚠️  Game not found in games table: ${game.title} (AppID: ${game.appid})`);
                    skipped++;
                    continue;
                  }

                  console.log(`  📥 Fetching download URLs for: ${game.title}`);
                  const downloadUrls = await fetchDownloadUrls(game.title);

                  if (downloadUrls.length === 0) {
                    console.log(`  ⚠️  No download URLs found for: ${game.title}`);
                    skipped++;
                    continue;
                  }

                  console.log(`  📁 Found ${downloadUrls.length} file(s)`);

                  await prisma.onlineFixes.upsert({
                    where: { appid: game.appid },
                    create: {
                      appid: game.appid,
                      urls: downloadUrls,
                      description: null,
                      category: 'WEB_ONLINE_FIX',
                      forMembership: false,
                    },
                    update: {
                      urls: downloadUrls,
                      updated_at: new Date(),
                    },
                  });

                  console.log(`  ✅ Inserted/Updated: ${game.title} (AppID: ${game.appid})`);
                  inserted++;
                } catch (error) {
                  console.log(`  ❌ Error with ${game.title}: ${error.message}`);
                  errors++;
                }
              }

              await prisma.$disconnect();

              console.log(`\n📊 Database Summary: ✅ ${inserted} inserted, ⏭️ ${skipped} skipped, ❌ ${errors} errors`);

              return { inserted, skipped, errors };
            } catch (error) {
              console.log(`\n❌ Database insertion failed: ${error.message}`);
              return { inserted: 0, skipped: 0, errors: games.length };
            }
          }

          async function main() {
            const maxPages = parseInt(process.env.MAX_PAGES || '2');
            const fetchAppIds = process.env.FETCH_APPIDS === 'true';

            console.log(`Scraping ${maxPages} pages (AppIDs: ${fetchAppIds})`);

            const { existingAppIds, existingGameNames } = await loadExistingGames();

            const allGames = [];
            let totalGames = 0;
            let skippedGames = 0;

            for (let page = 1; page <= maxPages; page++) {
              const result = await scrapePage(page, fetchAppIds);
              if (result && result.hasGames) {
                const newGames = result.games.filter(game => {
                  if (game.appid && existingAppIds.has(game.appid)) {
                    console.log(`  ⏭️  Skipping existing (AppID): ${game.title} (AppID: ${game.appid})`);
                    skippedGames++;
                    return false;
                  }

                  const normalizedTitle = normalizeGameName(game.title);
                  if (existingGameNames.has(normalizedTitle)) {
                    console.log(`  ⏭️  Skipping existing (Name): ${game.title}`);
                    skippedGames++;
                    return false;
                  }

                  return true;
                });

                result.games = newGames;

                if (newGames.length > 0) {
                  allGames.push(result);
                  totalGames += newGames.length;
                }
              } else {
                break;
              }
              if (page < maxPages) await new Promise(r => setTimeout(r, 2000));
            }

            const flatGames = allGames.flatMap(r => r.games);

            console.log(`\n✅ Scraped: ${totalGames + skippedGames} total, ${skippedGames} existing, ${totalGames} new`);

            if (flatGames.length > 0) {
              await insertGamesToDatabase(flatGames);
            }

            const jsonData = {
              version: new Date().toISOString(),
              totalPages: allGames.length,
              totalGames: totalGames,
              lastUpdated: new Date().toISOString(),
              pages: allGames,
              games: flatGames,
            };

            fs.writeFileSync('online-fix-games.json', JSON.stringify(jsonData, null, 2));
            fs.writeFileSync('online-fix-games.min.json', JSON.stringify(jsonData));

            const versionInfo = {
              version: jsonData.version,
              totalPages: jsonData.totalPages,
              totalGames: jsonData.totalGames,
              lastUpdated: jsonData.lastUpdated,
            };
            fs.writeFileSync('online-fix-version.json', JSON.stringify(versionInfo, null, 2));

            console.log(`\n✅ Scraping complete: ${totalGames} games from ${allGames.length} pages`);
          }

          main().catch(console.error);
          EOF

          # Run scraper
          node scrape-workflow.js

          # Extract stats for output
          TOTAL_GAMES=$(node -e "const data = require('./online-fix-games.json'); console.log(data.totalGames || 0);")
          LAST_UPDATED=$(node -e "const data = require('./online-fix-games.json'); console.log(data.lastUpdated || '');")

          echo "TOTAL_GAMES=${TOTAL_GAMES}" >> $GITHUB_OUTPUT
          echo "LAST_UPDATED=${LAST_UPDATED}" >> $GITHUB_OUTPUT
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}
          ONLINE_FIX_AUTH: ${{ secrets.ONLINE_FIX_AUTH }}
          ONLINE_FIX_DLE_USER_ID: ${{ secrets.ONLINE_FIX_DLE_USER_ID }}
          ONLINE_FIX_DLE_PASSWORD: ${{ secrets.ONLINE_FIX_DLE_PASSWORD }}
          ONLINE_FIX_PHPSESSID: ${{ secrets.ONLINE_FIX_PHPSESSID }}
          ONLINE_FIX_CF_CLEARANCE: ${{ secrets.ONLINE_FIX_CF_CLEARANCE }}
          MAX_PAGES: ${{ github.event.inputs.pages || '2' }}
          FETCH_APPIDS: ${{ github.event.inputs.fetch_appids || 'true' }}
          NEXT_PUBLIC_ALGOLIA_APP_ID: ${{ secrets.NEXT_PUBLIC_ALGOLIA_APP_ID }}
          NEXT_PUBLIC_ALGOLIA_SEARCH_API_KEY: ${{ secrets.NEXT_PUBLIC_ALGOLIA_SEARCH_API_KEY }}
          NEXT_PUBLIC_ALGOLIA_INDEX_NAME: ${{ secrets.NEXT_PUBLIC_ALGOLIA_INDEX_NAME || 'games' }}

      - name: Export onlineFixes table to JSON
        id: export
        run: |
          # Create export script
          cat > export-online-fixes.js << 'EOF'
          const { PrismaClient } = require('@prisma/client');
          const fs = require('fs');

          async function exportOnlineFixesTable() {
            const prisma = new PrismaClient();

            try {
              console.log('📥 Fetching data from onlineFixes table...');

              const onlineFixes = await prisma.onlineFixes.findMany({
                select: {
                  appid: true,
                  category: true,
                  forMembership: true,
                  created_at: true,
                  updated_at: true,
                  games: {
                    select: {
                      name: true,
                    }
                  },
                },
                orderBy: {
                  updated_at: 'desc',
                },
              });

              console.log(`✅ Fetched ${onlineFixes.length} records`);

              // Calculate statistics
              const stats = {
                totalGames: onlineFixes.length,
                categories: {},
                membershipGames: onlineFixes.filter(g => g.forMembership).length,
              };

              onlineFixes.forEach(game => {
                const cat = game.category || 'UNKNOWN';
                stats.categories[cat] = (stats.categories[cat] || 0) + 1;
              });

              // Create output data
              const output = {
                version: new Date().toISOString(),
                exportedAt: new Date().toISOString(),
                source: 'onlineFixes table',
                stats,
                games: onlineFixes.map(fix => ({
                  appid: fix.appid,
                  name: fix.games?.name || null,
                  category: fix.category,
                  forMembership: fix.forMembership,
                  createdAt: fix.created_at,
                  updatedAt: fix.updated_at,
                })),
              };

              // Write files
              fs.writeFileSync('online-fixes-export.json', JSON.stringify(output, null, 2));
              fs.writeFileSync('online-fixes-export.min.json', JSON.stringify(output));
              fs.writeFileSync('online-fixes-stats.json', JSON.stringify({
                version: output.version,
                exportedAt: output.exportedAt,
                source: output.source,
                stats: output.stats,
              }, null, 2));

              console.log('✅ Export complete');
              console.log(`   Total: ${stats.totalGames} games`);

              return stats.totalGames;
            } catch (error) {
              console.error('❌ Export failed:', error.message);
              throw error;
            } finally {
              await prisma.$disconnect();
            }
          }

          exportOnlineFixesTable().catch(console.error);
          EOF

          # Run export
          node export-online-fixes.js

          # Extract stats for output
          EXPORTED_GAMES=$(node -e "const data = require('./online-fixes-export.json'); console.log(data.stats.totalGames || 0);")
          EXPORTED_AT=$(node -e "const data = require('./online-fixes-export.json'); console.log(data.exportedAt || '');")

          echo "EXPORTED_GAMES=${EXPORTED_GAMES}" >> $GITHUB_OUTPUT
          echo "EXPORTED_AT=${EXPORTED_AT}" >> $GITHUB_OUTPUT
        env:
          DATABASE_URL: ${{ secrets.DATABASE_URL }}

      - name: Delete old release assets
        run: |
          gh release view online-fix-games --json assets --jq '.assets[].name' > old_assets.txt || echo "No existing release"

          if [ -f old_assets.txt ] && [ -s old_assets.txt ]; then
            echo "Deleting old assets..."
            while read asset; do
              echo "Deleting: $asset"
              gh release delete-asset online-fix-games "$asset" --yes || echo "Failed to delete $asset"
            done < old_assets.txt
          fi
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}

      - name: Upload to Release
        uses: softprops/action-gh-release@v1
        with:
          tag_name: online-fix-games
          name: 'Online-Fix Games Database'
          body: |
            🎮 Online-Fix Games Database

            **Scraping Stats:**
            - Total Games Scraped: ${{ steps.scrape.outputs.TOTAL_GAMES }}
            - Total Pages: ${{ github.event.inputs.pages || '2' }}
            - Last Updated: ${{ steps.scrape.outputs.LAST_UPDATED }}
            - AppIDs Included: ${{ github.event.inputs.fetch_appids || 'true' }}

            **Database Export Stats:**
            - Total Games in DB: ${{ steps.export.outputs.EXPORTED_GAMES }}
            - Exported At: ${{ steps.export.outputs.EXPORTED_AT }}

            **Scraping Files:**
            - `online-fix-games.json` - Formatted JSON with scraped games
            - `online-fix-games.min.json` - Minified JSON (scraped games)
            - `online-fix-version.json` - Version information only

            **Database Export Files:**
            - `online-fixes-export.json` - Formatted JSON from onlineFixes table
            - `online-fixes-export.min.json` - Minified JSON from onlineFixes table
            - `online-fixes-stats.json` - Statistics only

            **Usage:**
            ```javascript
            // Fetch scraped games (from online-fix.me)
            const scrapedData = await fetch('https://github.com/mejikuhibiniu1/workflow-releases/releases/download/online-fix-games/online-fix-games.json')
              .then(res => res.json());
            console.log(`Scraped games: ${scrapedData.totalGames}`);

            // Fetch database export (from onlineFixes table)
            const dbData = await fetch('https://github.com/mejikuhibiniu1/workflow-releases/releases/download/online-fix-games/online-fixes-export.json')
              .then(res => res.json());
            console.log(`DB games: ${dbData.stats.totalGames}`);

            // Check stats only
            const stats = await fetch('https://github.com/mejikuhibiniu1/workflow-releases/releases/download/online-fix-games/online-fixes-stats.json')
              .then(res => res.json());
            ```

            **Scraped Data Structure:**
            ```json
            {
              "version": "2025-10-31T10:00:00.000Z",
              "totalGames": 50,
              "games": [
                {
                  "title": "Game Name",
                  "link": "https://online-fix.me/...",
                  "appid": "123456"
                }
              ]
            }
            ```

            **Database Export Structure:**
            ```json
            {
              "version": "2025-10-31T10:00:00.000Z",
              "stats": { "totalGames": 500, "categories": {...} },
              "games": [
                {
                  "appid": "123456",
                  "name": "Game Name",
                  "category": "WEB_ONLINE_FIX",
                  "forMembership": false
                }
              ]
            }
            ```
          files: |
            online-fix-games.json
            online-fix-games.min.json
            online-fix-version.json
            online-fixes-export.json
            online-fixes-export.min.json
            online-fixes-stats.json
          prerelease: false
          make_latest: false
        env:
          GITHUB_TOKEN: ${{ secrets.GITHUB_TOKEN }}
